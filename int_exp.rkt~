#lang racket

(require racket/set racket/stream)
(require "utilities.rkt")
(require "interp.rkt")

(provide int-exp-passes compile-R0)


(define compile-R0
 (class object%
  (super-new)

  (define primitive-set
   (set '+ '- 'read))

  (define/public uniquify
   (lambda (env)
    (lambda (e)
     (match e
      [(? symbol?) (cdr (assq e env))]
      [(? integer?) e]
      [`(let ([,x ,(app (uniquify env) new-e)]) ,body)
        (let ([new-x (gensym x)])
         `(let ([,new-x ,new-e])
           ,((uniquify (cons `(,x . ,new-x) env)) body)))]
      [`(program ,e) `(program ,((uniquify env) e))]
      [`(,op ,es ...) #:when (set-member? primitive-set op)
      `(,op ,@(map (lambda (e) ((uniquify env) e)) es))]
      [else (error "Uniquify could not match " e)]))))

  (define/public flatten
   (lambda (need-temp)
    (lambda (e)
     (match e
      [(? symbol?) (values e '() '())]
      [(? integer?) (values e '() '())]
      [`(let ([,x ,(app (flatten #f) new-e e-stms e-vars)] ,body)
        (let-values ([(new-body body-stms body-vars) ((flatten need-temp) body)])
         (values new-body
                 (append e-stms `((assign ,x ,new-e)) body-stms)
                 (cons x (append e-vars body-vars)))))]
      [`(,op ,(app (flatten #t) new-es es-stms es-vars))
        #:when (set-member? primitive-set op)
        (let ([prim-exp `(,op ,@new-es)])
         (case need-temp
          [(#f) (values prim-exp es-stms es-vars)]
          [(#t) (let ([temp (gensym 'temp)])
                  (values temp 
                          (append es-stms `((assign temp ,prim-exp)))
                          (cons temp es-vars)))]))]
      [`(program ,e) 
        (let-values ([(e-exp e-stms e-vars) ((flatten #f) e)])
         `(program ,e-vars (append e-stms `((return ,e-exp)))))]
      [else (error "Flatten could not match " e)]))))
  
  
  ))


;; Passes
(define int-exp-passes
  (let ([compiler (new compile-R0)]
  [interp (new interp-R0)])
    (list 
    `("uniquify" ,(send compiler uniquify '())
      ,interp-scheme)
     `("flatten" ,(send compiler flatten #f)
       ,interp-C)
    ; `("instruction selection" ,(send compiler select-instructions)
    ;   ,interp-x86)
    ; `("assign homes" ,(send compiler assign-homes (void))
    ;   ,interp-x86)
    ; `("insert spill code" ,(send compiler patch-instructions)
    ;   ,interp-x86)
    ; `("print x86" ,(send compiler print-x86) #f)
    )))


;(define flatten
 ;(lambda (prog)
   ;(letrec ([x 0]
            ;[newtemp (lambda ()
                       ;(begin (set! x (+ x 1))
                              ;(string->symbol (string-append "temp." (number->string x)))))]
            ;[first-pass (lambda (prog)                                             
                          ;(match prog
                            ;[(? symbol?) (values '() prog)]
                            ;[(? integer?) (let ([ret-temp (newtemp)]) (values `((assign ,ret-temp ,prog)) ret-temp))]
                            ;[`(- ,e) (let ([ret-temp (newtemp)]) (values `((assign ,ret-temp ,prog)) ret-temp))]
                            ;[`(+ ,e1 ,e2) (cond [(and (not (nested? e1)) (not (nested? e2)))
                                                 ;(let ([ret-temp (newtemp)])
                                                   ;(values `((assign ,ret-temp ,prog)) ret-temp))]
                                                ;[(and (nested? e1) (not (nested? e2)))
                                                 ;(let-values ([(stms temp) (first-pass e1)])
                                                   ;(let ([ret-temp (newtemp)])
                                                     ;(values `(,@stms (assign ,ret-temp (+ ,temp ,e2))) ret-temp)))]
                                                ;[(and (not (nested? e1)) (nested? e2))
                                                 ;(let-values ([(stms temp) (first-pass e2)])
                                                   ;(let ([ret-temp (newtemp)])
                                                     ;(values `(,@stms (assign ,ret-temp (+ ,e1 ,temp))) ret-temp)))]
                                                ;[(and (nested? e1) (nested? e2))
                                                 ;(let-values ([(stms1 temp1) (first-pass e1)]
                                                               ;[(stms2 temp2) (first-pass e2)])
                                                   ;(let ([ret-temp (newtemp)])
                                                     ;(values `(,@stms1 ,@stms2 (assign ,ret-temp (+ ,temp1 ,temp2))) ret-temp)))])]
                            ;[`(let ([,var ,exp]) ,body)
                             ;(let ([stms-temp (if (not (nested? exp))
                                                  ;`((assign ,var ,exp))                                                   
                                                  ;(let-values ([(stms ret-ftemp) (first-pass exp)])
                                                    ;(replace stms ret-ftemp var)))])
                               ;(let-values ([(stms* ret-temp*) (first-pass body)])
                                 ;(values `(,@stms-temp ,@stms*) ret-temp*)))]))]                    
            ;[collect-vars (lambda (stm-list)
                            ;(foldr (lambda (stm col)
                                     ;(match stm
                                       ;[`(assign ,var ,exp) (if (memq var col)
                                                                ;col
                                                                ;(cons var col))]
                                       ;[`(return ,e) col]
                                       ;[else (error prog)]))
                                   ;'()
                                   ;stm-list))])
     ;(match prog
       ;[`(program ,e)
        ;(let-values ([(stms ret-temp) (first-pass e)])
          ;(let ([vars (collect-vars stms)])
            ;`(prog ,vars (,@stms (return ,ret-temp)))))]
       ;[else
        ;(error "should not happend")]))))

;(define select-instructions
  ;(lambda (prog)
    ;(letrec ([iterate (lambda (stms instr-select)
                        ;(if (null? stms)
                            ;'()
                            ;(cons (instr-select (car stms)) (iterate (cdr stms) instr-select))))]
              ;[instr-select (lambda (stm)
                              ;(match stm
                                ;[`(assign ,e1 (+ ,n1 ,n2)) (cond [(and (integer? n1) (integer? n2))
                                                                  ;`((movq (int ,n1) (var ,e1)) (addq (int ,n2) (var ,e1)))]
                                                                 ;[(and (integer? n1) (symbol? n2) 
                                                                       ;`((addq (int ,n1) (var ,n2))))]
                                                                 ;[(and (symbol? n1) (integer? n2))
                                                                  ;`((addq (int ,n2) (var ,n1)))]
                                                                 ;[(and (symbol? n1) (symbol? n2)) 
                                                                  ;`((addq (var ,n1) (var ,n2)))])]
                                ;[`(assign ,e1 (read)) `((callq read_int) (movq (reg rax) (var ,e1)))]
                                
                                ;[`(assign ,e1 ,e2) (cond [(integer? e2) `((movq (int ,e2) (var ,e1)))]
                                                         ;[else `((movq (var ,e2) (var ,e1)))])]
                                ;[`(return ,e) `((movq (reg rax) (var ,e)))]))])
      ;(match prog
        ;[`(prog ,vars ,stms) `(prog ,vars ,(iterate stms instr-select))]
        ;[else (error "Unkown prog in select-instruction")]))))

       


